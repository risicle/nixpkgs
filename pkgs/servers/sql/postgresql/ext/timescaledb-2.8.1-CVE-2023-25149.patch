Based on upstream 789bb26dfbf1aaf85163e5ddfc70fa6dae0894fb omitting
additions in src/telemetry/telemetry.c because 2.8.1 didn't yet do
SPI connections from there.

Still all places where the source does SPI_connect/_ext are now
protected by a search_path lockdown.

diff --git a/src/hypertable.c b/src/hypertable.c
index 39478385..c78e1edb 100644
--- a/src/hypertable.c
+++ b/src/hypertable.c
@@ -2825,10 +2825,16 @@ ts_hypertable_get_open_dim_max_value(const Hypertable *ht, int dimension_index,
 	if (NULL == dim)
 		elog(ERROR, "invalid open dimension index %d", dimension_index);
 
-	/* Query for the last bucket in the materialized hypertable */
+	/*
+	 * Query for the last bucket in the materialized hypertable.
+	 * Since this might be run as part of a parallel operation
+	 * we cannot use SET search_path here to lock down the
+	 * search_path and instead have to fully schema-qualify
+	 * everything.
+	 */
 	command = makeStringInfo();
 	appendStringInfo(command,
-					 "SELECT max(%s) FROM %s.%s",
+					 "SELECT pg_catalog.max(%s) FROM %s.%s",
 					 quote_identifier(NameStr(dim->fd.column_name)),
 					 quote_identifier(NameStr(ht->fd.schema_name)),
 					 quote_identifier(NameStr(ht->fd.table_name)));
diff --git a/src/telemetry/replication.c b/src/telemetry/replication.c
index 1d20a6b4..cd5f7f5e 100644
--- a/src/telemetry/replication.c
+++ b/src/telemetry/replication.c
@@ -23,6 +23,11 @@ ts_telemetry_replication_info_gather(void)
 	if (SPI_connect() != SPI_OK_CONNECT)
 		return info;
 
+	/* Lock down search_path */
+	res = SPI_exec("SET LOCAL search_path TO pg_catalog, pg_temp", 0);
+	if (res < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg("could not set search_path"))));
+
 	res = SPI_execute("SELECT cast(count(pid) as int) from pg_catalog.pg_stat_get_wal_senders() "
 					  "WHERE pid is not null",
 					  true, /* read_only */
diff --git a/tsl/src/continuous_aggs/materialize.c b/tsl/src/continuous_aggs/materialize.c
index 2c1649d5..5dd504b6 100644
--- a/tsl/src/continuous_aggs/materialize.c
+++ b/tsl/src/continuous_aggs/materialize.c
@@ -59,6 +59,11 @@ continuous_agg_update_materialization(SchemaAndName partial_view,
 	if (res != SPI_OK_CONNECT)
 		elog(ERROR, "could not connect to SPI in materializer");
 
+	/* Lock down search_path */
+	res = SPI_exec("SET LOCAL search_path TO pg_catalog, pg_temp", 0);
+	if (res < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg("could not set search_path"))));
+
 	/* pin the start of new_materialization to the end of new_materialization,
 	 * we are not allowed to materialize beyond that point
 	 */
diff --git a/tsl/src/continuous_aggs/refresh.c b/tsl/src/continuous_aggs/refresh.c
index 43a2d5b8..9fd56a4e 100644
--- a/tsl/src/continuous_aggs/refresh.c
+++ b/tsl/src/continuous_aggs/refresh.c
@@ -712,6 +712,11 @@ continuous_agg_refresh_internal(const ContinuousAgg *cagg,
 	if ((rc = SPI_connect_ext(SPI_OPT_NONATOMIC) != SPI_OK_CONNECT))
 		elog(ERROR, "SPI_connect failed: %s", SPI_result_code_string(rc));
 
+	/* Lock down search_path */
+	rc = SPI_exec("SET LOCAL search_path TO pg_catalog, pg_temp", 0);
+	if (rc < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg("could not set search_path"))));
+
 	/* Like regular materialized views, require owner to refresh. */
 	if (!pg_class_ownercheck(cagg->relid, GetUserId()))
 		aclcheck_error(ACLCHECK_NOT_OWNER,
diff --git a/tsl/src/reorder.c b/tsl/src/reorder.c
index 9f939b61..d30b2bce 100644
--- a/tsl/src/reorder.c
+++ b/tsl/src/reorder.c
@@ -243,6 +243,11 @@ tsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node)
 	if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
 		elog(ERROR, "SPI_connect failed: %s", SPI_result_code_string(rc));
 
+	/* Lock down search_path */
+	rc = SPI_exec("SET LOCAL search_path TO pg_catalog, pg_temp", 0);
+	if (rc < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg("could not set search_path"))));
+
 	/* perform the actual distributed chunk move after a few sanity checks */
 	chunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);
 
@@ -327,6 +332,11 @@ tsl_subscription_exec(PG_FUNCTION_ARGS)
 	if (SPI_connect() != SPI_OK_CONNECT)
 		elog(ERROR, "could not connect to SPI");
 
+	/* Lock down search_path */
+	res = SPI_exec("SET LOCAL search_path TO pg_catalog, pg_temp", 0);
+	if (res < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg("could not set search_path"))));
+
 	res = SPI_execute(subscription_cmd, false /* read_only */, 0 /*count*/);
 
 	if (res < 0)
@@ -364,6 +374,11 @@ tsl_copy_chunk_cleanup_proc(PG_FUNCTION_ARGS)
 	if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)
 		elog(ERROR, "SPI_connect failed: %s", SPI_result_code_string(rc));
 
+	/* Lock down search_path */
+	rc = SPI_exec("SET LOCAL search_path TO pg_catalog, pg_temp", 0);
+	if (rc < 0)
+		ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg("could not set search_path"))));
+
 	/* perform the cleanup/repair depending on the stage */
 	chunk_copy_cleanup(operation_id);
 
